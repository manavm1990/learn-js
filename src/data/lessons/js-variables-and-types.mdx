# Variables, Data Types, and Operators

Review of JavaScript variables (var, let, const), primitive types, operators, and type coercion with a focus on modern best practices.

## Introduction

### Why This Review Matters

You've written JavaScript before. You know `let x = 5` creates a variable. But after months away, it's the subtle details that slip - the difference between `null` and `undefined`, why `[] == false` is true, or why modifying an object affects all variables pointing to it.

This lesson refreshes the fundamentals that trip up even experienced developers. We'll use browser DevTools experiments to rediscover JavaScript's quirks before you encounter them in frameworks like React.

### What We'll Cover

- Modern variable declarations and why `const` is your default
- All seven primitive types and when you'll encounter each
- Operators beyond basic math - the ones that actually matter
- Type coercion - JavaScript's most surprising "feature"
- Reference vs value - the root cause of many framework state bugs

Open your browser's Developer Console now (F12 â†’ Console tab). Everything we do today happens there.

## Core Concept Overview

### Variable Declarations: The Modern Trinity

JavaScript has three ways to declare variables, but only two matter in modern code:

```javascript
// Type these in your console
const permanent = "Can't reassign this";
let changeable = "Can reassign this";
var ancient = "Never use this"; // Seriously, never

// Try to reassign each (you'll get an error for const)
permanent = "Trying to change"; // TypeError!
changeable = "This works"; // Fine
ancient = "This works too"; // Works but has weird scoping
```

**The Rule**: Default to `const`. Only use `let` when you must reassign the actual value (not modify contents). Never use `var`.

### The Five Primitive Types You'll Actually Use

Primitives are JavaScript's atomic values - they can't be broken down further. Type these experiments to see each one:

```javascript
// The Five That Matter
const text = "Hello"; // string
const count = 42; // number
const isActive = true; // boolean
const empty = null; // null (intentional absence)
let notYetSet; // undefined (unintentional absence)

// Check their types
console.log(typeof text); // "string"
console.log(typeof count); // "number"
console.log(typeof isActive); // "boolean"
console.log(typeof empty); // "object" (JavaScript's oldest bug!)
console.log(typeof notYetSet); // "undefined"
```

Note: JavaScript has two other primitive types (Symbol and BigInt) but you'll rarely encounter them in web development.

### Objects: Everything Else

If it's not a primitive, it's an object. This includes arrays, functions, dates, and actual objects:

```javascript
// All of these are objects
const user = { name: "Alex", age: 30 }; // object
const items = [1, 2, 3]; // array (object)
const greet = function () {
  return "Hi";
}; // function (object)
const today = new Date(); // date (object)

// Proof they're all objects
console.log(typeof user); // "object"
console.log(typeof items); // "object" (arrays are objects!)
console.log(typeof greet); // "function" (special case, but still object)
console.log(typeof today); // "object"

// Better way to check arrays
console.log(Array.isArray(items)); // true
console.log(Array.isArray(user)); // false
```

### Operators: Beyond Basic Math

#### Arithmetic Operators

```javascript
// The basics you know
10 + 5; // 15 - addition
10 - 5; // 5  - subtraction
10 * 5; // 50 - multiplication
10 / 5; // 2  - division
10 % 3; // 1  - remainder (super useful for cycling)
10 ** 2; // 100 - exponentiation (power)

let score = 10;
score++; // 11 (increment)
score--; // 10 (decrement)
score += 5; // 15 (add and assign)
score *= 2; // 30 (multiply and assign)
```

#### Comparison Operators

```javascript
// Always use strict equality
5 === 5; // true  - same value and type
5 === "5"; // false - different types
5 !== "5"; // true  - not strictly equal

// Never use loose equality (causes bugs)
5 == "5"; // true - JavaScript converts types (bad!)
0 == false; // true - confusing type coercion
"" == false; // true - even more confusing

// Ordering comparisons
10 > 5; // true
10 >= 10; // true
5 < 10; // true
5 <= 5; // true
```

#### Logical Operators

```javascript
// AND - both must be true
true && true; // true
true && false; // false

// OR - at least one must be true
true || false; // true
false || false; // false

// NOT - flips the boolean
!true; // false
!false; // true
!!5; // true (double NOT converts to boolean)
!!0; // false
```

## Hands-On Application

### Exercise 1: Build a Simple Type Checker

Let's build a practical function that checks types like a mini version of what React does internally. Type this step-by-step:

```javascript
// Step 1: Create the basic type checker
function checkType(value) {
  // Your turn: return the type of the value
  // Handle the null bug we learned about
}

// Step 2: Test with primitives
console.log(checkType("hello")); // Should return "string"
console.log(checkType(42)); // Should return "number"
console.log(checkType(true)); // Should return "boolean"
console.log(checkType(null)); // Should return "null" (not "object"!)
console.log(checkType(undefined)); // Should return "undefined"

// Step 3: Test with objects
console.log(checkType([])); // Should return "array"
console.log(checkType({})); // Should return "object"
console.log(checkType(function () {})); // Should return "function"
```

**Solution (try first, then check):**

```javascript
function checkType(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  return typeof value;
}
```

### Exercise 2: The Reference Trap - React State Simulation

This is why state management in frameworks can be tricky. Let's simulate how React handles state updates:

```javascript
// Step 1: Create a simple "component state" simulator
let componentState = { count: 0, user: { name: "Alex" } };

// Step 2: Wrong way to update state (mutates original)
function updateStateWrong(newData) {
  // This is what beginners do - modifies the original!
  Object.assign(componentState, newData);
  return componentState;
}

// Step 3: Right way to update state (creates new object)
function updateStateRight(newData) {
  // This is what React does - creates new object
  return { ...componentState, ...newData };
}

// Test both approaches
console.log("Initial:", componentState);

const oldState = componentState;
updateStateWrong({ count: 1 });
console.log("After wrong update:", oldState === componentState); // true - same object!

componentState = { count: 0, user: { name: "Alex" } }; // Reset
const newState = updateStateRight({ count: 1 });
console.log("After right update:", oldState === newState); // false - different objects!
console.log("Old state:", componentState);
console.log("New state:", newState);
```

## Type Coercion Chaos

JavaScript tries to be "helpful" by converting types automatically. This causes bugs:

```javascript
// Addition with strings concatenates
"5" + 3         // "53" - converts 3 to string
5 + "3"         // "53" - converts 5 to string
"5" + "3"       // "53" - both strings

// Other operators convert to numbers
"5" - 3         // 2 - converts "5" to number
"5" * "3"       // 15 - converts both to numbers
"10" / "2"      // 5 - converts both to numbers

// Weird but true
true + true     // 2 (true becomes 1)
false + false   // 0 (false becomes 0)
[] + []         // "" (empty string!)
[] + {}         // "[object Object]" (wat?)

// The equality mess
0 == false      // true (both become 0)
"" == false     // true (both become 0)
[] == false     // true (array becomes "")
[] == ![]       // true (mind-blown)
```

## Falsy Values

Memorize these six falsy values. Everything else is truthy:

```javascript
// The six falsy values
Boolean(false); // false
Boolean(0); // false
Boolean(""); // false (empty string)
Boolean(null); // false
Boolean(undefined); // false
Boolean(NaN); // false

// Common gotchas - these are TRUTHY
Boolean("0"); // true (non-empty string)
Boolean("false"); // true (non-empty string)
Boolean([]); // true (empty array is truthy!)
Boolean({}); // true (empty object is truthy!)
Boolean(-1); // true (any non-zero number)

// Practical check
if ([]) {
  console.log("Empty array is truthy!"); // This runs!
}

// Common gotcha in frameworks
const items = [];
items.length && "Show this"; // Returns 0, not false!
// In frameworks like React, this would render "0" on the page

// The fix
items.length > 0 && "Show this"; // Returns false properly
```

## `const` DOESN'T MEAN 'CONSTANT'

Understanding why `const` works with objects is crucial for modern JavaScript:

```javascript
// const prevents reassignment of the variable binding
const num = 5;
// num = 10;  // Error! Can't reassign

// But object/array CONTENTS can change
const user = { name: "Sarah", age: 25 };
user.age = 26; // Totally fine - modifying contents
user.location = "NYC"; // Adding properties is fine
delete user.age; // Removing properties is fine
console.log(user); // { name: "Sarah", location: "NYC" }

// The variable still points to the same object
// user = { name: "John" };  // Error! Can't reassign

// Same with arrays
const numbers = [1, 2, 3];
numbers.push(4); // Fine - modifying contents
numbers[0] = 10; // Fine - changing elements
console.log(numbers); // [10, 2, 3, 4]
// numbers = [5, 6, 7];  // Error! Can't reassign
```

### Nullish Operators

Modern JavaScript adds operators specifically for handling `null` and `undefined`:

```javascript
// Nullish coalescing (??) - only null/undefined trigger default
let username = null;
console.log(username ?? "Anonymous"); // "Anonymous"

username = "";
console.log(username ?? "Anonymous"); // "" (empty string isn't null!)

username = 0;
console.log(username ?? "Anonymous"); // 0 (zero isn't null!)

// Compare with OR operator
username = "";
console.log(username || "Anonymous"); // "Anonymous" (empty string is falsy)

username = 0;
console.log(username || "Anonymous"); // "Anonymous" (0 is falsy)

// Optional chaining (?.) - safely access nested properties
const user = { name: "Alex" };
console.log(user.address?.street); // undefined (no error!)

// Without optional chaining
// console.log(user.address.street);  // TypeError!

// Combining both
const city = user.address?.city ?? "Unknown";
console.log(city); // "Unknown"
```

## Advanced Concepts & Comparisons

### JavaScript's Type System

JavaScript is "dynamically typed" - variables don't have types, values do. The same variable can hold any type:

```javascript
let flexible = 42; // number
flexible = "Hello"; // now string
flexible = true; // now boolean
flexible = [1, 2, 3]; // now array
flexible = null; // now null
```

This flexibility is both a strength (quick prototyping) and weakness (runtime errors). TypeScript adds optional static typing to catch these errors early.

### Why typeof null is "object"

This is JavaScript's most famous bug, kept for backward compatibility:

```javascript
console.log(typeof null); // "object" - wrong but permanent

// How to properly check for null
const value = null;
console.log(value === null); // true - correct way
```

### NaN: Not a Number (that's a number)

```javascript
console.log(typeof NaN); // "number" (ironic)
console.log(NaN === NaN); // false (only value not equal to itself!)
console.log(isNaN(NaN)); // true
console.log(Number.isNaN(NaN)); // true (better - no type coercion)

// How you get NaN
console.log(0 / 0); // NaN
console.log(parseInt("hello")); // NaN
console.log(Math.sqrt(-1)); // NaN
```

## Troubleshooting & Best Practices

### Common Mistakes to Avoid

**Using == instead of ===**

```javascript
// Bad - unpredictable
if (userInput == 5) {
}

// Good - explicit
if (userInput === 5) {
}
if (Number(userInput) === 5) {
} // If you need conversion
```

**Mutating when you meant to copy**

```javascript
// Bad - modifies original (problematic for state management)
const original = [1, 2, 3];
const copy = original;
copy.push(4); // original is now [1, 2, 3, 4]!

// Good - creates new array
const original = [1, 2, 3];
const copy = [...original]; // Spread creates new array
copy.push(4); // original still [1, 2, 3]
```

**Forgetting that arrays/objects are truthy**

```javascript
// Bad - always true even when empty
const items = [];
if (items) {
  // This is always true!
  console.log("Has items");
}

// Good - check length
if (items.length > 0) {
  console.log("Has items");
}
```

**Not handling null/undefined**

```javascript
// Bad - crashes if user is null
const name = user.name;

// Good - safe access
const name = user?.name ?? "Guest";
```

### Best Practices

1. **Use `const` by default** - Only `let` when you must reassign
2. **Always use `===` for equality** - Never `==`
3. **Be explicit with booleans** - `array.length > 0` not just `array.length`
4. **Use optional chaining** - `user?.address?.city` prevents crashes
5. **Provide defaults with ??** - `value ?? defaultValue` for null/undefined

## Wrap-Up & Assessment

### Quick Check

Can you answer these without looking back?

1. What's the difference between `null` and `undefined`?
2. Why does `typeof null` return "object"?
3. Name all six falsy values
4. Why can you modify a `const` array?
5. What's the difference between `??` and `||`?
6. Why does `"5" + 3` give "53" but `"5" - 3` gives 2?

### Exercise 3: Debug the Props - React Prep

Let's practice catching type errors before they break your React components. Fix these "broken" component props:

```javascript
// Step 1: Here's a component that expects specific prop types
function Button(props) {
  // This is what the component expects:
  // text: string
  // isDisabled: boolean
  // onClick: function
  // count: number

  console.log(`Button text: ${props.text}`);
  console.log(`Is disabled: ${props.isDisabled}`);
  console.log(`Count: ${props.count}`);

  if (props.onClick) {
    props.onClick();
  }
}

// Step 2: These props have type problems - fix them!
const brokenProps = {
  text: 123, // Should be string
  isDisabled: "false", // Should be boolean
  onClick: "not a function", // Should be function
  count: "5", // Should be number
};

// Step 3: Fix the props (try first, then check solution below)
const fixedProps = {
  // Your fixes here
};

// Test both
console.log("=== BROKEN PROPS ===");
Button(brokenProps);

console.log("=== FIXED PROPS ===");
Button(fixedProps);
```

**Solution (try first!):**

```javascript
const fixedProps = {
  text: "Click me", // Convert to string
  isDisabled: false, // Convert to actual boolean
  onClick: () => console.log("Button clicked!"), // Actual function
  count: 5, // Convert to actual number
};
```

### Hands-On Challenge: State Update Practice

Practice the "create new object" pattern that React requires:

```javascript
// Step 1: Start with component state
const userState = {
  name: "Alex",
  age: 25,
  preferences: {
    theme: "dark",
    language: "en",
  },
};

// Step 2: Wrong way (mutates original - breaks React!)
function updateStateWrong(newData) {
  userState.age = newData.age; // BAD: mutates original
  return userState;
}

// Step 3: Right way (creates new object - React approved!)
function updateStateRight(newData) {
  // Your turn: create and return a new object
  // Hint: Use spread operator { ...oldObject, ...newData }
}

// Step 4: Test both approaches
const originalState = userState;

console.log("Original:", userState);

// Test wrong way
const wrongResult = updateStateWrong({ age: 26 });
console.log("Wrong way - same object?", wrongResult === originalState); // Should be true (bad!)

// Reset for next test
userState = {
  name: "Alex",
  age: 25,
  preferences: { theme: "dark", language: "en" },
};

// Test right way
const rightResult = updateStateRight({ age: 26 });
console.log("Right way - different object?", rightResult !== userState); // Should be true (good!)
console.log("Right result:", rightResult);
```

### Key Takeaways

- **Primitives copy by value, objects copy by reference** - This will be crucial for state management
- **JavaScript coerces types automatically** - Be explicit to avoid surprises
- **Six falsy values to memorize** - Everything else is truthy (including `[]` and `{}`)
- **`const` prevents reassignment, not modification** - You can change object contents
- **Modern operators (`?.` and `??`)** prevent common null/undefined errors

Next lesson: Functions and Scope - where closures become essential for modern JavaScript patterns.
